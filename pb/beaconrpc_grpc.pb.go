// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: beaconrpc.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BlockchainRPCClient is the client API for BlockchainRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlockchainRPCClient interface {
	SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error)
	GetSlotNumber(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SlotNumberResponse, error)
	GetBlockHash(ctx context.Context, in *GetBlockHashRequest, opts ...grpc.CallOption) (*GetBlockHashResponse, error)
	GetLastBlockHash(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetBlockHashResponse, error)
	GetState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetStateResponse, error)
	GetStateRoot(ctx context.Context, in *GetStateRootRequest, opts ...grpc.CallOption) (*GetStateRootResponse, error)
	GetValidatorRoot(ctx context.Context, in *GetValidatorRootRequest, opts ...grpc.CallOption) (*GetValidatorRootResponse, error)
	GetEpochInformation(ctx context.Context, in *EpochInformationRequest, opts ...grpc.CallOption) (*EpochInformationResponse, error)
	GetForkData(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ForkData, error)
	GetProposerForSlot(ctx context.Context, in *GetProposerForSlotRequest, opts ...grpc.CallOption) (*GetProposerForSlotResponse, error)
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error)
	SubmitAttestation(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetMempool(ctx context.Context, in *MempoolRequest, opts ...grpc.CallOption) (*BlockBody, error)
	GetValidatorInformation(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*Validator, error)
	GetListeningAddresses(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListeningAddressesResponse, error)
	Connect(ctx context.Context, in *ConnectMessage, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CrosslinkStream(ctx context.Context, in *CrosslinkStreamRequest, opts ...grpc.CallOption) (BlockchainRPC_CrosslinkStreamClient, error)
	GetGenesisTime(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GenesisTimeResponse, error)
	GetValidatorProof(ctx context.Context, in *GetValidatorProofRequest, opts ...grpc.CallOption) (*GetValidatorProofResponse, error)
}

type blockchainRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewBlockchainRPCClient(cc grpc.ClientConnInterface) BlockchainRPCClient {
	return &blockchainRPCClient{cc}
}

func (c *blockchainRPCClient) SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error) {
	out := new(SubmitBlockResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/SubmitBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetSlotNumber(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SlotNumberResponse, error) {
	out := new(SlotNumberResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetSlotNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetBlockHash(ctx context.Context, in *GetBlockHashRequest, opts ...grpc.CallOption) (*GetBlockHashResponse, error) {
	out := new(GetBlockHashResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetBlockHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetLastBlockHash(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetBlockHashResponse, error) {
	out := new(GetBlockHashResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetLastBlockHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetStateResponse, error) {
	out := new(GetStateResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetStateRoot(ctx context.Context, in *GetStateRootRequest, opts ...grpc.CallOption) (*GetStateRootResponse, error) {
	out := new(GetStateRootResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetStateRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetValidatorRoot(ctx context.Context, in *GetValidatorRootRequest, opts ...grpc.CallOption) (*GetValidatorRootResponse, error) {
	out := new(GetValidatorRootResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetValidatorRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetEpochInformation(ctx context.Context, in *EpochInformationRequest, opts ...grpc.CallOption) (*EpochInformationResponse, error) {
	out := new(EpochInformationResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetEpochInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetForkData(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ForkData, error) {
	out := new(ForkData)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetForkData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetProposerForSlot(ctx context.Context, in *GetProposerForSlotRequest, opts ...grpc.CallOption) (*GetProposerForSlotResponse, error) {
	out := new(GetProposerForSlotResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetProposerForSlot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error) {
	out := new(GetBlockResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) SubmitAttestation(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/SubmitAttestation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetMempool(ctx context.Context, in *MempoolRequest, opts ...grpc.CallOption) (*BlockBody, error) {
	out := new(BlockBody)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetMempool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetValidatorInformation(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*Validator, error) {
	out := new(Validator)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetValidatorInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetListeningAddresses(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListeningAddressesResponse, error) {
	out := new(ListeningAddressesResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetListeningAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) Connect(ctx context.Context, in *ConnectMessage, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) CrosslinkStream(ctx context.Context, in *CrosslinkStreamRequest, opts ...grpc.CallOption) (BlockchainRPC_CrosslinkStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &BlockchainRPC_ServiceDesc.Streams[0], "/pb.BlockchainRPC/CrosslinkStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainRPCCrosslinkStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BlockchainRPC_CrosslinkStreamClient interface {
	Recv() (*CrosslinkMessage, error)
	grpc.ClientStream
}

type blockchainRPCCrosslinkStreamClient struct {
	grpc.ClientStream
}

func (x *blockchainRPCCrosslinkStreamClient) Recv() (*CrosslinkMessage, error) {
	m := new(CrosslinkMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainRPCClient) GetGenesisTime(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GenesisTimeResponse, error) {
	out := new(GenesisTimeResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetGenesisTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainRPCClient) GetValidatorProof(ctx context.Context, in *GetValidatorProofRequest, opts ...grpc.CallOption) (*GetValidatorProofResponse, error) {
	out := new(GetValidatorProofResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainRPC/GetValidatorProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlockchainRPCServer is the server API for BlockchainRPC service.
// All implementations must embed UnimplementedBlockchainRPCServer
// for forward compatibility
type BlockchainRPCServer interface {
	SubmitBlock(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error)
	GetSlotNumber(context.Context, *emptypb.Empty) (*SlotNumberResponse, error)
	GetBlockHash(context.Context, *GetBlockHashRequest) (*GetBlockHashResponse, error)
	GetLastBlockHash(context.Context, *emptypb.Empty) (*GetBlockHashResponse, error)
	GetState(context.Context, *emptypb.Empty) (*GetStateResponse, error)
	GetStateRoot(context.Context, *GetStateRootRequest) (*GetStateRootResponse, error)
	GetValidatorRoot(context.Context, *GetValidatorRootRequest) (*GetValidatorRootResponse, error)
	GetEpochInformation(context.Context, *EpochInformationRequest) (*EpochInformationResponse, error)
	GetForkData(context.Context, *emptypb.Empty) (*ForkData, error)
	GetProposerForSlot(context.Context, *GetProposerForSlotRequest) (*GetProposerForSlotResponse, error)
	GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error)
	SubmitAttestation(context.Context, *Attestation) (*emptypb.Empty, error)
	GetMempool(context.Context, *MempoolRequest) (*BlockBody, error)
	GetValidatorInformation(context.Context, *GetValidatorRequest) (*Validator, error)
	GetListeningAddresses(context.Context, *emptypb.Empty) (*ListeningAddressesResponse, error)
	Connect(context.Context, *ConnectMessage) (*emptypb.Empty, error)
	CrosslinkStream(*CrosslinkStreamRequest, BlockchainRPC_CrosslinkStreamServer) error
	GetGenesisTime(context.Context, *emptypb.Empty) (*GenesisTimeResponse, error)
	GetValidatorProof(context.Context, *GetValidatorProofRequest) (*GetValidatorProofResponse, error)
	mustEmbedUnimplementedBlockchainRPCServer()
}

// UnimplementedBlockchainRPCServer must be embedded to have forward compatible implementations.
type UnimplementedBlockchainRPCServer struct {
}

func (UnimplementedBlockchainRPCServer) SubmitBlock(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBlock not implemented")
}
func (UnimplementedBlockchainRPCServer) GetSlotNumber(context.Context, *emptypb.Empty) (*SlotNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlotNumber not implemented")
}
func (UnimplementedBlockchainRPCServer) GetBlockHash(context.Context, *GetBlockHashRequest) (*GetBlockHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockHash not implemented")
}
func (UnimplementedBlockchainRPCServer) GetLastBlockHash(context.Context, *emptypb.Empty) (*GetBlockHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastBlockHash not implemented")
}
func (UnimplementedBlockchainRPCServer) GetState(context.Context, *emptypb.Empty) (*GetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetState not implemented")
}
func (UnimplementedBlockchainRPCServer) GetStateRoot(context.Context, *GetStateRootRequest) (*GetStateRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStateRoot not implemented")
}
func (UnimplementedBlockchainRPCServer) GetValidatorRoot(context.Context, *GetValidatorRootRequest) (*GetValidatorRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorRoot not implemented")
}
func (UnimplementedBlockchainRPCServer) GetEpochInformation(context.Context, *EpochInformationRequest) (*EpochInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEpochInformation not implemented")
}
func (UnimplementedBlockchainRPCServer) GetForkData(context.Context, *emptypb.Empty) (*ForkData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForkData not implemented")
}
func (UnimplementedBlockchainRPCServer) GetProposerForSlot(context.Context, *GetProposerForSlotRequest) (*GetProposerForSlotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProposerForSlot not implemented")
}
func (UnimplementedBlockchainRPCServer) GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedBlockchainRPCServer) SubmitAttestation(context.Context, *Attestation) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAttestation not implemented")
}
func (UnimplementedBlockchainRPCServer) GetMempool(context.Context, *MempoolRequest) (*BlockBody, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMempool not implemented")
}
func (UnimplementedBlockchainRPCServer) GetValidatorInformation(context.Context, *GetValidatorRequest) (*Validator, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorInformation not implemented")
}
func (UnimplementedBlockchainRPCServer) GetListeningAddresses(context.Context, *emptypb.Empty) (*ListeningAddressesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListeningAddresses not implemented")
}
func (UnimplementedBlockchainRPCServer) Connect(context.Context, *ConnectMessage) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedBlockchainRPCServer) CrosslinkStream(*CrosslinkStreamRequest, BlockchainRPC_CrosslinkStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CrosslinkStream not implemented")
}
func (UnimplementedBlockchainRPCServer) GetGenesisTime(context.Context, *emptypb.Empty) (*GenesisTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGenesisTime not implemented")
}
func (UnimplementedBlockchainRPCServer) GetValidatorProof(context.Context, *GetValidatorProofRequest) (*GetValidatorProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorProof not implemented")
}
func (UnimplementedBlockchainRPCServer) mustEmbedUnimplementedBlockchainRPCServer() {}

// UnsafeBlockchainRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlockchainRPCServer will
// result in compilation errors.
type UnsafeBlockchainRPCServer interface {
	mustEmbedUnimplementedBlockchainRPCServer()
}

func RegisterBlockchainRPCServer(s grpc.ServiceRegistrar, srv BlockchainRPCServer) {
	s.RegisterService(&BlockchainRPC_ServiceDesc, srv)
}

func _BlockchainRPC_SubmitBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).SubmitBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/SubmitBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).SubmitBlock(ctx, req.(*SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetSlotNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetSlotNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetSlotNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetSlotNumber(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetBlockHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetBlockHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetBlockHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetBlockHash(ctx, req.(*GetBlockHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetLastBlockHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetLastBlockHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetLastBlockHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetLastBlockHash(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetState(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetStateRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStateRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetStateRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetStateRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetStateRoot(ctx, req.(*GetStateRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetValidatorRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetValidatorRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetValidatorRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetValidatorRoot(ctx, req.(*GetValidatorRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetEpochInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpochInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetEpochInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetEpochInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetEpochInformation(ctx, req.(*EpochInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetForkData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetForkData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetForkData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetForkData(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetProposerForSlot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProposerForSlotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetProposerForSlot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetProposerForSlot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetProposerForSlot(ctx, req.(*GetProposerForSlotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetBlock(ctx, req.(*GetBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_SubmitAttestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Attestation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).SubmitAttestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/SubmitAttestation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).SubmitAttestation(ctx, req.(*Attestation))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetMempool(ctx, req.(*MempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetValidatorInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetValidatorInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetValidatorInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetValidatorInformation(ctx, req.(*GetValidatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetListeningAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetListeningAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetListeningAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetListeningAddresses(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).Connect(ctx, req.(*ConnectMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_CrosslinkStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CrosslinkStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainRPCServer).CrosslinkStream(m, &blockchainRPCCrosslinkStreamServer{stream})
}

type BlockchainRPC_CrosslinkStreamServer interface {
	Send(*CrosslinkMessage) error
	grpc.ServerStream
}

type blockchainRPCCrosslinkStreamServer struct {
	grpc.ServerStream
}

func (x *blockchainRPCCrosslinkStreamServer) Send(m *CrosslinkMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _BlockchainRPC_GetGenesisTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetGenesisTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetGenesisTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetGenesisTime(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainRPC_GetValidatorProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainRPCServer).GetValidatorProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainRPC/GetValidatorProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainRPCServer).GetValidatorProof(ctx, req.(*GetValidatorProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BlockchainRPC_ServiceDesc is the grpc.ServiceDesc for BlockchainRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlockchainRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.BlockchainRPC",
	HandlerType: (*BlockchainRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitBlock",
			Handler:    _BlockchainRPC_SubmitBlock_Handler,
		},
		{
			MethodName: "GetSlotNumber",
			Handler:    _BlockchainRPC_GetSlotNumber_Handler,
		},
		{
			MethodName: "GetBlockHash",
			Handler:    _BlockchainRPC_GetBlockHash_Handler,
		},
		{
			MethodName: "GetLastBlockHash",
			Handler:    _BlockchainRPC_GetLastBlockHash_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _BlockchainRPC_GetState_Handler,
		},
		{
			MethodName: "GetStateRoot",
			Handler:    _BlockchainRPC_GetStateRoot_Handler,
		},
		{
			MethodName: "GetValidatorRoot",
			Handler:    _BlockchainRPC_GetValidatorRoot_Handler,
		},
		{
			MethodName: "GetEpochInformation",
			Handler:    _BlockchainRPC_GetEpochInformation_Handler,
		},
		{
			MethodName: "GetForkData",
			Handler:    _BlockchainRPC_GetForkData_Handler,
		},
		{
			MethodName: "GetProposerForSlot",
			Handler:    _BlockchainRPC_GetProposerForSlot_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BlockchainRPC_GetBlock_Handler,
		},
		{
			MethodName: "SubmitAttestation",
			Handler:    _BlockchainRPC_SubmitAttestation_Handler,
		},
		{
			MethodName: "GetMempool",
			Handler:    _BlockchainRPC_GetMempool_Handler,
		},
		{
			MethodName: "GetValidatorInformation",
			Handler:    _BlockchainRPC_GetValidatorInformation_Handler,
		},
		{
			MethodName: "GetListeningAddresses",
			Handler:    _BlockchainRPC_GetListeningAddresses_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _BlockchainRPC_Connect_Handler,
		},
		{
			MethodName: "GetGenesisTime",
			Handler:    _BlockchainRPC_GetGenesisTime_Handler,
		},
		{
			MethodName: "GetValidatorProof",
			Handler:    _BlockchainRPC_GetValidatorProof_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CrosslinkStream",
			Handler:       _BlockchainRPC_CrosslinkStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "beaconrpc.proto",
}
